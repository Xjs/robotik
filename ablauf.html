<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
    	<meta charset="UTF-8">
        <title>GPS auf Rädern</title>
        <style type="text/css">
			@import url('style.css');
        </style>
        <!--[if lte IE 7]>
        <style type="text/css">
        	
        </style>
        <![endif]-->
    </head>
    <body>
	    <div class="container" id="header">
			<div id="head">GPS auf Rädern</div>
			<ul id="navigation">
				<li><a href="index.html">Start</a></li>
				<li><a href="team.html">Team</a></li>
				<li><a href="ablauf.html">Ablauf</a></li>
				<li><a href="anleitung.html">Betrieb</a></li>
				<li><a href="probleme.html">Probleme</a></li>
				<li><a href="ausblick.html">Ausblick</a></li>
				<li><a href="quellen.html">Quellen</a></li>
				<li><a href="links.html">Links</a></li>
			</ul>
		</div>
		<div style="clear: all; height: 2.9em; margin-top: -4px; width: 100%;"></div>
		<hr style="position: relative; top: -2px;" />
		<div class="container" id="body">
			<h1>1. Planung</h1>
			<p>
Nach intensiver Recherche und ausführlichen Teambesprechungen wurde die Entscheidung gefällt, den Roboter so modular wie möglich aufzubauen:
Die Ansteuerung des Motorreglers und des Lenkservos sollte ein Mikrocontroller übernehmen.
Auf der nächsthöheren Schicht, sollte der Raspberry Pi liegen, welcher alle komplexeren Berechnungen, wie die Routenplanung, den Ausweichalgorithmus für Hindernisse und die Verarbeitung der Inputdaten der unterschiedlichen Sensoren durchführt.
Auf diese Weise wären einzelne Teile leicht austauschbar und böten so viele Möglichkeiten zur Weiterentwicklung des Roboters.
			</p>
			<h2>Hardware</h2>
			<img src="pictures/auto.png" alt="Top-Down-Ansicht des Autos" />
			<p class="caption">Übersicht über das Auto. Alle Hardwarekomponenten sind zu erkennen.</p>
			<h3>RC-Auto</h3>
			<p>
Bei der Auswahl des RC Autos wurden Kriterien wie Größe und Robustheit besonders beachtet. Es war klar, dass das Auto genug Platz bieten müsse um den Raspberry Pi, das GPS-Modul und die Distanzmessungssensoren gut unterzubringen. Eine Stoßstange und gute Federung waren wichtig, um dem Roboter so viel Sicherheit wie möglich zu bieten.
			</p>
			<h3>Mikrocontroller</h3>
			<p>
Es wurde uns empfohlen, die hauseigene Mikrocontroller-Platine des Robotiklabors der Universität Heidelberg zu nutzen. Diese wurde anhand der Lötanleitung zusammengebaut und mit einem ATmega168 bestückt.
			</p>
			<h3>Distanzmessungssensoren</h3>
			<p>
Um eine Distanz zu messen, können Infrarot- oder Ultraschallsensoren verwendet werden. Aufgrund der einfachen Funktionsweise, verhältnismäßig großer Reichweite und geringem Anschaffungspreos fiel die Wahl auf Ultraschallsensoren, speziell auf das Modell HC-SR04 welches sich durch gute Bewertungen auszeichnet und durch seinen geringen Preis sogar in mehreren Instanzen eingesetzt werden kann, ohne das Budget zu sprengen. Zwei Ultraschallsensoren wurden für ausreichend befunden.
			</p>
			<h3>GPS-Modul</h3>
			<p>
Es handelt sich um das Modell ublox LEA-6H, welches nicht nur GPS-Daten liefert sondern auch einen eingebauten Kompass hat. Dieses wurde von den Betreuern des Praktikums ausgewählt.
			</p>
			<h2>Software</h2>
			<p>
Die Verwendung des Betriebssystems Raspbian für den Raspberry Pi war die einzige Vorgabe bezüglich der Software, die gemacht wurde.
Für die benötigten Libraries zur Ansteuerung der GPIO-Pins des Raspberry Pis und des GPS-Moduls fiel die Wahl auf die viel-verwendeten Libraries RPi.GPIO und gpsd.
Der selbst zu entwickelnde Code wurde in Sinnabschnitte (Hardwareansteuerung/-kommunikation, Routenplanung, Ausweichroutine) untergliedert und auf die unterschiedlichen Teammitglieder verteilt, wobei immer wieder Rücksprache gehalten wurde und der Code gegenseitig korrigiert wurde.
Für die Kommunikation zwischen Raspberry Pi und ATmega, wurde ein eigenes Kommunikationsprotokoll in mehreren Prototypen entworfen.
			</p>
			<h1>2. Verbindung der Komponenten</h1>
			<p>
Die ersten Aufgaben bestanden darin, sich mit der Elektronik vertraut zu machen und zu lernen, wie einzelne Komponenten (z.B. die Servos des Autos) angesteuert werden können.
			</p>
			<p>
Servomotoren werden über PWM (Pulse-Width-Modulation) Signale gesteuert. Hierbei gibt die Länge des Signals vor, wie sich der Motor bewegt. Etwa alle 20 ms erwartet der Motor einen Input, dieser ist typischerweise zwischen 1 und 2 ms lang.
Um die genauen Werte für den Motor und den Lenkservo des Autos zu bestimmen, wurden die von der Fernbedienung übermittelten Signale mit einem Oszilloskop gemessen.
			</p>
			<img src="pictures/servos.png" style="width: 800px;" alt="Exemplarische PWM-Signale und Reaktionen der Motoren" />
			<p class="caption">
				Exemplarische PWM-Signale und Reaktionen der Motoren
			</p>
			<p> </p>
			<p>
			<table>
				<tr>
					<th>PWM-Signallänge [µs]</th>
					<th>Reaktion Lenkservo</th>
					<th>Reaktion Fahrtmotor</th>
				</tr>
				<tr>
					<td>1000</td>
					<td>---</td>
					<td>Vollgas rückwärts</td>
				</tr>
				<tr>
					<td>1170</td>
					<td>Max. links</td>
					<td>Rückwärts</td>
				</tr>
				<tr>
					<td>1500</td>
					<td>Nullposition</td>
					<td>Ausgeschaltet</td>
				</tr>
				<tr>
					<td>1800</td>
					<td>Max. rechts</td>
					<td>Vorwärts</td>
				</tr>
				<tr>
					<td>1952</td>
					<td>---</td>
					<td>Vollgas vorwärts</td>
				</tr>
			</table>
			<p class="caption">
				Messergebnisse
			</p>
			</p>
			<p>
Die oben dargestellten Messergebnisse wurden dann in Code gegossen, um abstrahierende Fahrfunktionen zu implementieren. 
Diese wurden zunächst auf dem ATmega in der Programmiersprache C unter Verwendung des Basis-Codes des Robotiklabors umgesetzt und funktionierten einwandfrei.
Um den Fahrtregler und damit den Fahrtmotor und den Lenkservo anzusteuern, wurde der ATmega über die Antennenbuchse mit dem Fahrtregler verbunden.
			</p>
			<p>
Das Kernstück des Roboters ist der Raspberry Pi und mit diesem mussten alle anderen Komponenten verbunden werden. Die designierten  UART- und I²C-Pins des Raspberry Pis wurden verwendet um den GPS-Chip bzw. den Kompass anzuschließen.
<br>Da jedoch auch die Verbindung zwischen Raspberry und ATmega über UART hergestellt werden musste, wurden zwei GPIO-Pins des Pis verwendet um eine weitere UART-Schnittstelle zu bitbangen (d. h. über Software zu emulieren). Hierzu kam die PIGPIO Library zum Einsatz. Über das selbstgeschriebene Kommunikationsprotokoll sollten nun Pi und ATmega kommunizieren können, jedoch gab es trotz funktionierender Kommunikationsschnittstelle Komplikationen mit dem Mikrocontroller, die in sinnvoller Zeit nicht überwunden werden konnten. So musste der ursprüngliche Entwurf überarbeitet werden.</br> 
Der Mikrocontroller wurde aus dem Aufbau entfernt, die Fahrtfunktionen mussten auf dem Raspberry Pi in Python neu implementiert werden, und die PWM-Signale, die der ATmega zuvor generiert hatte, mussten nun durch den Pi erzeugt werden. Für letzeres wurde die RPi.GPIO Library verwendet, welche Funktionen für die Generierung von PWM-Signalen bereitstellt.
<br>Außerdem mussten die beiden Ultraschallsensoren mit dem Raspberry verbunden werden. Dies geschah über eine kleine selbstverlötete Platine, welche sicherstellen soll, dass die fließenden Spannungen nicht zu hoch sind (die Ultraschallsensoren arbeiten mit 5V und senden auch Signale in dieser Höhe, die GPIO-Pins des Raspberrys dürfen jedoch nicht mehr als 3.3V erhalten).</br>
			</p>
			<img src="pictures/ultraschallsensoren.png" style="width: 700px;" alt="Schaltplan Ultraschallsensoren" />
			<p class="caption">
				Schaltplan: Verbindung der Ultraschallsensoren mit dem Raspberry Pi
			</p>
			<p>
Um alle Teile des Roboters mit Strom zu versorgen, werden zwei Batterie-Packs verwendet: das eine liefert Strom für den Motorregler und die Motoren, das zweite versorgt den Raspberry Pi, die Ultraschallsensoren sowie das GPS-Modul. Damit der Pi nicht zu viel Spannung erhält, wurde eine Spannungsregler-Schaltung gelötet.
			</p>
			<h1>3. Programmierung</h1>
			<p>
Der Programmcode lässt sich in vier größere Sinnabschnitte gliedern:
			</p>
			<ul>
				<li>die Hauptroutine, die das Grundgerüst bildet</li>
				<li>die Navigationsroutine, die GPS-Daten verarbeitet und Wegberechnungen durchführt</li>
				<li>die Hinderniserkennungsroutine, die Gegenständen auf der zu fahrenden Bahn ausweicht</li>
				<li>Hardwarenaher Code, welcher Daten von Sensoren verarbeitet und die Motoren steuert</li>
			</ul>
			<p>
			Im Folgenden wird nun genauer auf diese einzelnen Abschnitte eingegangen.
			</p>
			<h2>Hauptroutine</h2>
			<p>Die main-Funktion bedient sich dreier Hilfsfunktionen:</p>
			<ul>
				<li><b>angular_speed(radius, speed):</b>
							<br>
							berechnet die Winkelgeschwindigkeit bei gegebenem Kurvenradius und gegebener Geschwindigkeit.
							</br>
				</li>
				<p></p>
				<li><b>is_at(current, target):</b>
							<br>
							prüft ob sich das Auto bis auf einen Schwellenwert genau am Ziel befindet.
							</br>
				</li>
				<p></p>
				<li><b>correct_course(direction, angle, radius, speed=SPEED, watcher=None):</b>
							<br>
							korrigiert den Kurs durch befahren einer Kreisbahn in der durch direction vorgegebenen Richtung. Die Länge der Kreisbahn ist durch angle und 								radius vorgegeben. Die Geschwindigkeit ist variabel, es wird jedoch empfohlen so langsam wie möglich zu fahren. Watcher ist ein Objekt der 								Klasse Watcher, welche für die Hinderniserkennung zuständig ist. Während der Kurskorrektur wird auf Hindernisse geprüft.
							</br>
				</li>
			</ul>
				<br></br>
				<p>
				Gehen wir nun näher auf die Funktionsweise der Hauptroutine ein.
				<img src="pictures/flussdiagramm.png" alt="Flussdiagramm der main-Funktion" />
					<p class="caption">
					Überblick über die Funktionsweise der Hauptroutine
					</p>
				</p>
				<br></br>
				<p>
				Zunächst wird überprüft, ob die über die Kommandozeile beim Starten des Programms eingegebenen Werte gültige Eingaben sind:
				</p>
			<pre>
if __name__ == '__main__':
	try:
		target = tuple(float(i) for i in sys.argv[1:3])
	except ValueError:
		target = None
	mainRoutine(target)
			</pre>
			<p>und:</p>
			<pre>
def mainRoutine(target):
	if target is None or len(target) != 2:
		print "no reasonable target given"
		return
			</pre>
			<p>
Sind die Eingaben nicht von der Form "Zahl_1 Zahl_2", so beendet das Programm.
Sind die Eingaben richtig, dann werden die nötigen Instanzen unterschiedlicher Klassen erzeugt und initialisiert:
			</p>
			<pre>
	tracker = GPSTracker()
	navigator = Navigator(tracker)
	navigator.setRadius(RADIUS)
	
	watcher = Watcher()
			</pre>
			<p>
Die Klasse <em>GPSTracker</em> ermöglicht die Position des Autos sowie dessen Orientierung anhand der Kompassdaten zu bestimmen.
Die Klasse <em>Navigator</em> berechnet den Kurs, der angesteuert werden muss um das Auto zum Ziel zu führen.
<em>Watcher</em> implementiert die Überwachung der Strecke vor dem Auto sowie den Ausweichalgorithmus für etwaige Hindernisse.
			</p>
			<p>
<br>Als Nächstes muss auf ein GPS-Signal gewartet werden. Sobald dieses vorliegt wird in eine Endlosschleife eingetreten und zunächst überprüft, ob das Auto gerade stillsteht.</br>
Ist dies der Fall, so steht es noch am Anfang seiner Reise. Daher muss zunächst die Orientierung bestimmt werden, damit der Navigator den Kurs berechnen kann. Dazu muss die Liste der letzten Positionen des GPSTrackers gefüllt werden, also fährt das Auto zunächst einige Meter, füllt dabei über <em>tracker.getPosition()</em> die Liste und hält dann wieder an. Später wurde das GPS-Modul auf einer Stange befestigt, und damit wurde diese Weise der Orientierungsbestimmung überflüssig. In der letzten Version der Software wird die Orientierung über den Kompass abgefragt. Dennoch wurde dieser Code-Abschnitt beibehalten um bei Kompass-Störungen leicht auf diese gut funktionierende Art der Orientierungsfindung zurückgreifen zu können.
<br>Fährt das Auto jedoch, so wird lediglich die Variable <em>driving</em> auf True gesetzt.</br>
			</p>
			<pre>
	while True:
		if is_at(curPos, tracker.getPosition()): 	#Car stands still
			print "standing"
			start = time.time()
			print "driving at", speed
			drive(speed)					 #Drive for a few meters.
			while (time.time() - start) < 2: #While driving save positions to tracker.
				watcher.obstancle()
				tracker.getPosition()
			stop()
		
			line = None
		else:
			driving = True
			</pre>
			<p>
Dann wird überprüft ob das Auto bereits an seinem Ziel angekommen ist. Falls dem so ist, hält es an und das Programm bricht aus der Schleife aus.
Ist es nicht an seinem Ziel, wird überprüft ob sich das Auto auf dem richtigen Kurs befindet und gegebenenfalls auf den korrekten Kurs gebracht.
			</p>
			<p>
Die letzte if-Anweisung prüft, ob das Auto gerade fährt - und wenn dem so ist, speichert es seine Position in die Liste der letzten Positionen des GPSTrackers und prüft auf Hindernisse.
			</p>
			<h2>Navigationsroutine</h2>
			<h3>GPS- und Kompass-Tracking</h3>
			<p>
Die erste wesentliche Komponente des Navigationscodes ist das GPS-Tracking. Die Klasse <em>GPSPoller</em> stellt die Verbindung zu einem auf dem Raspberry Pi laufenden <em>gpsd</em>-Prozess her und fragt im Hintergrund stets Daten ab. Die Klasse <em>Compass</em> wird verwendet, um die I2C-Daten des angeschlossenen Kompasses auszulesen und auszuwerten; sie stellt auch Kalibrierungsfunktionen bereit. Ein Objekt der <em>GPSTracker</em>-Klasse legt intern einen GPSPoller und einen Compass an und ermöglicht es so, zu jedem Zeitpunkt die Methoden <em>getPosition</em> und <em>getOrientation</em> bereitzustellen, die Ort und Richtung des GPS-Autos zurückgeben.
			</p>
			<p>
Kontakt zu gpsd und Speicherung der Daten erfolgt in einem eigenen Thread:
			</p>
			<pre>
class GPSPoller(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		global gpsd
		gpsd = gps(mode = WATCH_ENABLE)
		self.current_value = None
		self.running = True
	
	def run(self):
		global gpsd
		while self.running:
			gpsd.next()
			</pre>
			<p>
<em>getPosition</em> bildet einen Mittelwert über die letzten drei Längen- und Breitengradwerte, die von gpsd direkt zurückgegeben werden, mit einem zeitlichen Abstand von 100&nbsp;ms. Dieser Mittelwert wird in der Form (latitude, longitude) zurückgegeben.
			</p>
			<h3>Details zum Kompass</h3>
			<p>
Die <em>Compass</em>-Klasse muss zunächst auf I2C-Ebene mit dem Kompassmodul kommunizieren. Dazu wurden die Hilfsfunktionen read_byte, read_word, read_word_2c und write_byte geschrieben.
			</p>
			<p>
Die Daten, die das Kompassmodul liefert, geben gewissermaßen die Position (x, y, z) der Spitze einer Kompassnadel an. Um hieraus eine Himmelsrichtung ermitteln zu können, wird das Modul einmal um 360 Grad gedreht, während kontinuierlich Samples genommen werden. Diese werden genutzt, um den Mittelpunkt einzustellen. Dann kann mit dem Arkustangens der Winkel zu Norden ermittelt werden. Weiter muss noch eine Eichung auf Norden durchgeführt werden. Hieraus ergeben sich die Werte x_offset, y_offset und angle_offset, die sich nach der Kalibrierung ergeben und zur Eichung des Kompasses verwendet werden.
			</p>
			<p>
<em>getOrientation</em> liest die Daten aus, errechnet trigonometrisch den Winkel und normalisiert ihn so, dass stets der Winkel im Uhrzeigersin zwischen Norden und der Kompassausrichtung angegeben wird.
			</p>
			<h3>Navigation</h3>
			<p>
Die Klasse <em>Navigator</em> nutzt ein GPSTracker-Objekt zur Positionsbestimmung und stellt die Funktionen <em>navigate</em> und <em>on_track</em> bereit.
			</p>
			<p>
Die Navigation funktioniert prinzipiell folgendermaßen: Ausgehend von der Position und Orientierung des Roboters und eines Kurvenradius, der im Voraus eingestellt wird, werden zwei Kreise betrachtet, die der Roboter bei entsprechendem Lenkeinschlag nach links oder rechts fahren kann. Es wird dann der Kreis ausgewählt, dessen Mittelpunkt näher am angesteuerten Zielpunkt liegt, und Tangenten an diesen Kreis durch den Zielpunkt gelegt. Diejenige Tangente, die auf dem Kreisbogen näher am Roboter liegt, wird dann angestrebt.
			</p>
			<p>
Zu beachten ist bei der ganzen Berechnung, dass wir direkt auf GPS-Daten, d. h. Längen- und Breitengradangaben arbeiten. Die geometrische Berechnung erfolgt im Wesentlichen kartesisch, d. h. die Genauigkeit ist nur bei vergleichsweise geringen Distanzen (einige zehn Kilometer sollten kein Problem sein) gewährleistet. Um trotzdem keinen Unsinn zu berechnen, werden die Mittelpunkte der Kreise exakt anhand des Breitengrades berechnet.
			</p>
			<p>
<em>navigate</em> gibt nach dieser Berechnung folgenden Datensatz zurück:
			</p>
			<ul>
				<li>Einen Kreisbogen, beschrieben durch:
					<ul>
						<li>Drehrichtung (1 für Gegenuhrzeigersinn, -1 für Uhrzeigersinn)</li>
						<li>Winkel auf der Kreisbahn (0-2π)</li>
						<li>Kurvenradius, d. h. Radius des Kreises, von dessen Bahn ein Stück abgefahren wird</li>
					</ul>
				</li>
				<li>Eine gerade Linie, eben die Tangente durch den Zielpunkt, beschrieben durch:
					<ul>
						<li>Startpunkt</li>
						<li>Endpunkt</li>
					</ul>
				</li>
			</ul>
			<p>
Die Methode <em>on_track</em> erhält als Argument eine Tangente, wie als zweiter Rückgabewert von <em>navigate</em> erhalten, und prüft, ob der aktuelle Standpunkt nicht weiter als ein gewisser Schwellenwert (0.00001 hat sich als praktikabel erwiesen) von ebendieser Tangenten entfernt ist. Wenn die Entfernung kleiner als das ist, befindet sich das Auto noch auf dieser Linie, ist also <em>on track</em>, es wird True zurückgegeben. Wenn sie größer ist, wird False zurückgegeben – es gab wohl aus irgendeinem Grund (Hindernisse, Ungenauigkeit der GPS-Daten, Ungenauigkeit im Abfahren der Kreisbahn) eine Abweichung vom navigierten Pfad, woraufhin die Hauptroutine die Navigation erneut starten wird.
			</p>
			<img src="pictures/navigation.png" alt="Beispielhafte Navigation" />
			<p class="caption">
				Beispielhafter Ablauf von Navigation und Re-Navigation
			</p>
			<h3>Kleine Helferlein</h3>
			<p>
Die Datei <em>helpers.py</em> enthält einige Hilfsfunktionen.
			</p>
			<ul>
				<li><b>sign(x)</b>: <br>Gibt das Vorzeichen der Zahl x zurück.</br></li><p></p>
				<li><b>angle_to_north(start, end)</b>: <br>start und end sind jeweils Tupel (x, y) und definieren so eine Strecke. angle_to_north gibt den Winkel im Uhrzeigersinn zu Norden (sprich der y-Achse) zurück.</br></li><p></p>
				<li><b>normalize(angle)</b>: <br>Normalisiert einen Winkel in Radian auf [0..2π].</br></li><p></p>
				<li><b>distance(a, b)</b>: <br>Errechnet den kartesischen Abstand zwischen den Punkten a und b.</br></li><p></p>
				<li><b>to_rad(arg)</b>, <b>to_deg(rad)</b>, <b>point_to_rad(*args)</b>: <br>Konvertieren zwischen Grad und Radian.</br></li><p></p>
				<li><b>great_circle_distance(p1, p2)</b>: <br>Errechnet eine geometrisch korrekte Distanz in Metern zwischen zwei GPS-Koordinaten p1 und p2, basierend auf der <a href="http://www.movable-type.co.uk/scripts/latlong.html">gleichrechtwinkligen Näherung</a> (alternativ auch möglich und programmiert: mit der Haversine-Formel – aber der Genauigkeitsgewinn war nicht den Rechenaufwand wert).</br></li><p></p>
				<li><b>distance_to_angular_distance(d)</b>, <b>angular_distance_to_distance(d)</b>: <br>Konvertieren Abstände von GPS-Koordinaten zu Abständen in Metern.</br></li><p></p>
				<li><b>oriented_angle(v1, v2)</b>: <br>Berechnet den Winkel zwischen den Vektoren v1 und v2, wobei der Drehsinn von v1 nach v2 geht.<br></li><p></p>
				<li><b>debug_print(*args)</b>: <br>Gibt eine Ausgabe dann und nur dann, wenn die globale Variable DEBUG nicht auf False gesetzt ist.</br></li><p></p>
			</ul>
			<h2>Hinderniserkennungsroutine</h2>
			<img src="pictures/obstancle.png" style="width: 500px;" alt="Schema der Hinderniserkennung" />
			<p class="caption">
				Schema der Hinderniserkennung
			</p>
			<p>
Die Hinderniserkennung basiert auf einem einfachen Prinzip. Zwei Untraschallsensoren messen regelmäßig die Zeit ausgesandter und wieder empfangener Schallpulse. Daraus lässt sich bei einer Reflexion eine Entfernung bestimmen. Anhand der Datenpunkte zweier Sensoren kann dann nicht nur die Entfernung, sondern auch die Richtung zu einem Objekt bestimmt werden. Dieses Prinzip machen wir uns zunutze. Jeder der Sensoren sendet in jedem Programm-Zyklus mindestens ein Signal und misst damit die Entfernung zu möglichen Hindernissen. Sieht das Programm ein Objekt unter einem gewissen Schwellwert, kann es anhand der beiden Daten entscheiden, auf welcher Seite es am einfachsten passieren kann und lenkt in Richtung der größeren Distanz. Da im Moment eines erkannten Hindernisses die Navigation zweirangig ist übernimmt das Programm bis zum Verschwinden (Maximaldistanz) des Hindernisses die Kontrolle.
<br><br>
Die Hinderniserkennungsroutine wird durch die Klasse <em>Watcher</em> umgesetzt, welche folgende Funktionen enthält:
			</p>
			<h3>alarm()</h3>
			<pre>
def alarm(self):
		alarmL=self.watchlistL[-1]
		alarmR=self.watchlistR[-1]
		
		if((self.watchlistL[-1]-self.watchlistR[-1])*(self.watchlistL[-2]-self.watchlistR[-2]) < 0):
			if(alarmL < alarmR):
				alarmR = alarmR - bias
			if(alarmL > alarmR):
				alarmL = alarmL - bias
		
		return (alarmL, alarmR)
			</pre>
			<p>
<em>alarm</em> gibt die zuletzt gemessenen Abstände zu Objekten auf der linken und rechten Seite des Autos zurück. Der wichtigste Teil dieser Routine ist allerdings die Funktion beim Wechsel der Richtung von der größeren Distanz einen bias abzuziehen. Das Prinzip ist denkbar einfach, sorgt aber dafür, dass Objekte direkt vor dem Auto, wo die Entfernungsmessung aufgrund ihres eigenen Messfehlers nicht entscheiden kann in welcher Richtung dieses liegt, trotzdem zuverlässig umfahren werden, da das Auto dazu gedrängt wird eine einmal eingeschlagene Richtung beizubehalten. Aufgrund der statistischen Schwankung im Bereich des Messfehlers ist diese Entscheidung dann mehr oder weniger zufällig, was bei direkt frontalen Objekten aber keinen Nachteil verursacht.
			</p>
			<h3>watch()</h3>
			<p>
fragt die Ultraschallsensoren ab und füllt jeweils eine Liste für jeden Sensor mit Messwerten.
			</p>
			<h3>obstancle()</h3>
			<pre>
			if (R > L):
						if(R*movefactor > 0.715):
							steer(R*movefactor)
						else:
							steer(0.715)
			</pre>
			<p>
Hauptroutine der Hinderniserkennung. Fragt über <em>alarm</em> die Entfernungen zu Hindernissen ab und reagiert entsprechend. Beispielhaft ist hier der Code für die Lenkung nach Rechts dargestellt. Ist die Distanz zum rechten Sensor (R) größer als zu linken (L) gibt <em>obstancle</em> den Befehl die Räder nach links einzuschlagen. Wichtig ist in diesem Fall die Skalierung mit der Entfernung. Weit entfernte Hindernisse werden deshalb mit nur minimaler Änderung umfahren und auch bei einem großen Ausweichmanöver sorgt die Routine dafür, dass das Objekt ohne ruckartige Manöver entsprechend dem Verhalten eines echten Autofahrers umfährt. Simple but effective!
			</p>
			<h2>Hardwarenaher Code</h2>
			<p>
Der hardwarenahe Code umfasst zum einen die Dateien <em>controlServos.py</em> und <em>drive.py</em>, welche für die Ansteuerung der Motoren des Autos zuständig sind und die Fahrtfunktionen enthalten und zum anderen die Datei <em>getDistance.py</em>, welche die Ultraschallsensoren abfragt.
			</p>
			<h3>controlServos.py</h3>
			<p>
definiert Variablen für die Länge der zu übermittelnden PWM-Signale für geradeaus lenken/nicht fahren (BASE), rechts lenken (RIGHT), links lenken (LEFT), vorwärts fahren (FORWARD) und rückwärts fahren (BACK). Um Gradierung in Lenkung und Geschwindigkeit zu erlauben, wurden diese Variablen in Abhängigkeit von BASE definiert, sodass man sie mit einem Faktor verwenden kann/muss.</br>
Weiterhin werden die grundlegenden Fahrtfunktionen <em>steerS(deg)</em> und <em>driveS(speed)</em> implementiert, welche jeweils eine Fließkommazahl zwischen -1 (Anschlag rechts bzw. Vollgas rückwärts) und 1 (Anschlag links bzw. Vollgas vorwärts) erwarten.
			</p>
			<h3>drive.py</h3>
			<p>
definiert Fahrfunktionen auf einer höheren Ebene. Anstelle von Gradierungen wird <em>drive(speed)</em> die gewünschte Geschwindigkeit in Metern pro Sekunde, <em>steer_only(radius)</em> der Kurvenradius in Metern und <em>steer_at(speed, radius)</em> beides übergeben. Die <em>stop</em>-Funktion hält das Auto ohne Input an.
			</p>
			<h3>getDistance.py</h3>
			<p>
setzt benötigte GPIO-Pins des Raspberry Pis so, dass sie für den Input (echo) und Output (trig) für die beiden Ultraschall-Sensoren verwendet werden können.
Unter Verwendung der Zeit, die die Schallwellen benötigen um nach dem Senden wieder am Sensor anzukommen (<em>timeElapsed</em>) wird die Distanz zum erkannten Objekt in Metern berechnet und zurückgegeben.
			</p>
		</div>
    </body>
</html>
