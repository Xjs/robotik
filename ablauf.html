<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>GPS auf Rädern</title>
        <style type="text/css">
			@import url('style.css');
        </style>
        <!--[if lte IE 7]>
        <style type="text/css">
        	
        </style>
        <![endif]-->
    </head>
    <body>
	    <div class="container" id="header">
			<div id="head">GPS auf Rädern</div>
			<ul id="navigation">
				<li><a href="index.html">Start</a></li>
				<li><a href="team.html">Team</a></li>
				<li><a href="ablauf.html">Ablauf</a></li>
				<li><a href="anleitung.html">Betrieb</a></li>
				<li><a href="probleme.html">Probleme</a></li>
				<li><a href="ausblick.html">Ausblick</a></li>
				<li><a href="quellen.html">Quellen</a></li>
				<li><a href="links.html">Links</a></li>
			</ul>
		</div>
		<div style="clear: all; height: 2.5em; margin-top: -4px; width: 100%;"></div>
		<hr style="position: relative; top: -2px;" />
		<div class="container" id="body">
			<p>
Am Ende des Projektes steht ein funktionsfähiger Roboter, welcher der Aufgabenstellung entsprechend autonom seinen Weg zu eingegebenen GPS-Koordinaten findet ohne dabei gegen Hindernisse zu fahren.
			</p>
			<h1>1. Planung</h1>
			<p>
Nach intensiver Recherche und ausführlichen Teambesprechungen wurde die Entscheidung gefällt, den Roboter so modular wie möglich aufzubauen:
Die Ansteuerung des Motorreglers und des Lenkservos sollte ein Mikrocontroller übernehmen.
Auf der nächsthöheren Schicht, sollte der Raspberry Pi liegen, welcher alle komplexeren Berechnungen, wie die Routenplanung, den Ausweichalgorithmus für Hindernisse und die Verarbeitung der Inputdaten der unterschiedlichen Sensoren durchführt.
Auf diese Weise wären einzelne Teile leicht austauschbar und böten so viele Möglichkeiten zur Weiterentwicklung des Roboters.
			</p>
			<h2>Hardware</h2>
			<h3>RC-Auto</h3>
			<p>
Bei der Auswahl des RC Autos wurden Kriterien wie Größe und Robustheit besonders beachtet. Es war klar, dass das Auto genug Platz bieten müsse um den Raspberry Pi, das GPS-Modul und die Distanzmessungssensoren gut unterzubringen. Eine Stoßstange und gute Federung waren wichtig, um dem Roboter so viel Sicherheit wie möglich zu bieten.
			</p>
			<h3>Mikrocontroller</h3>
			<p>
Vorgabe war, die hauseigene Mikrocontroller-Platine des Robotiklabors der Universität Heidelberg zu nutzen. Diese wurde anhand der Lötanleitung zusammengebaut und mit einem ATmega168 bestückt.
			</p>
			<h3>Distanzmessungssensoren</h3>
			<p>
Um eine Distanz zu messen, können Infrarot- oder Ultraschallsensoren verwendet werden. Aufgrund der größeren Reichweite von Ultraschallsensoren fiel die Wahl auf diese, speziell auf das Modell HC-SR04 welches sich durch gute Bewertungen auszeichnet und durch seinen geringen Preis sogar in mehreren Instanzen eingesetzt werden kann, ohne das Budget zu sprengen. Zwei Ultraschallsensoren wurden für ausreichend befunden.
			</p>
			<h3>GPS-Modul</h3>
			<p>
Es handelt sich um das Modell ublox LEA-6H, welches nicht nur GPS-Daten liefert sondern auch einen eingebauten Kompass hat. Dieses wurde von den Betreuern des Praktikums ausgewählt.
			</p>
			<h2>Software</h2>
			<p>
Die Verwendung des Betriebssystems Raspbian für den Raspberry Pi war die einzige Vorgabe bezüglich der Software, die gemacht wurde.
Für die benötigten Libraries zur Ansteuerung der GPIO-Pins des Raspberry Pis und des GPS-Moduls fiel die Wahl auf die viel-verwendeten Libraries RPi.GPIO und gpsd.
Der selbst zu entwickelnde Code wurde in Sinnabschnitte (Hardwareansteuerung/-kommunikation, Routenplanung, Ausweichroutine) untergliedert und auf die unterschiedlichen Teammitglieder verteilt, wobei immer wieder Rücksprache gehalten wurde und der Code gegenseitig korrigiert wurde.
Für die Kommunikation zwischen Raspberry Pi und ATmega, wurde ein eigenes Kommunikationsprotokoll in mehreren Prototypen entworfen.
			</p>
			<h1>2. Verbindung der Komponenten</h1>
			<p>
Die ersten Aufgaben bestanden darin, sich mit der Elektronik vertraut zu machen und zu lernen, wie einzelne Komponenten (z.B. die Servos des Autos) angesteuert werden können.
			</p>
			<p>
Servomotoren werden über PWM (Pulse-Width-Modulation) Signale gesteuert. Hierbei gibt die Länge des Signals vor, wie sich der Motor bewegt. Etwa alle 20 ms erwartet der Motor einen Input, dieser ist typischerweise zwischen 1 und 2 ms lang.
Um die genauen Werte für den Motor und den Lenkservo des Autos zu bestimmen, wurden die von der Fernbedienung übermittelten Signale mit einem Oszilloskop gemessen.
			</p>
			<p><em>Messergebnisse</em></p><!--TODO-->
			<p>
Die oben dargestellten Messergebnisse wurden dann in Code gegossen, um abstrahierende Fahrfunktionen zu implementieren. 
Diese wurden zunächst auf dem ATmega in der Programmiersprache C unter Verwendung des Basis-Codes des Robotiklabors umgesetzt und funktionierten einwandfrei.
Um den Fahrtregler und damit den Fahrtmotor und den Lenkservo anzusteuern, wurde der ATmega über die Antennenbuchse mit dem Fahrtregler verbunden.
			</p>
			<p><em>Grafik?</em></p><!--TODO-->
			<p>
Das Kernstück des Roboters ist der Raspberry Pi und mit diesem mussten alle anderen Komponenten verbunden werden. Die designierten  UART- und I²C-Pins des Raspberry Pis wurden verwendet um den GPS-Chip bzw. den Kompass anzuschließen.
Da jedoch auch die Verbindung zwischen Raspberry und ATmega über UART hergestellt werden musste, wurden zwei GPIO-Pins des Pis verwendet um eine weitere UART-Schnittstelle zu bitbangen (über Software zu emulieren). Hierzu kam die PIGPIO Library zum Einsatz. Über das selbstgeschriebene Kommunikationsprotokoll sollten nun Pi und ATmega kommunizieren können, jedoch gab es trotz funktionierender Kommunikationsschnittstelle Komplikationen mit dem Mikrocontroller, die in sinnvoller Zeit nicht überwunden werden konnten. So musste der ursprüngliche Entwurf überarbeitet werden. 
Der Mikrocontroller wurde aus dem Aufbau entfernt, die Fahrfunktionen mussten auf dem Raspberry Pi in Python neu implementiert werden, und die PWM-Signale, die der ATmega zuvor generiert hatte, mussten nun durch den Pi erzeugt werden. Für letzeres wurde die RPi.GPIO Library verwendet, welche Funktionen für die Generierung von PWM-Signalen bereitstellt.
Außerdem mussten die beiden Ultraschallsensoren mit dem Raspberry verbunden werden. Dies geschah über eine kleine selbstverlötete Platine, welche sicherstellen soll, dass die fließenden Spannungen nicht zu hoch sind (die Ultraschallsensoren arbeiten mit 5V und senden auch Signale in dieser Höhe, die GPIO-Pins des Raspberrys dürfen jedoch nicht mehr als 3.3V erhalten).
			</p>
			<p><em>Schaltplan</em></p><!--TODO-->
			<p>
Um alle Teile des Roboters mit Strom zu versorgen, werden zwei Batterie-Packs verwendet: das eine liefert Strom für den Motorregler und die Motoren, das zweite versorgt den Raspberry Pi, die Ultraschallsensoren sowie das GPS-Modul. Damit der Pi nicht zu viel Spannung erhält, wurde eine Spannungsregler-Schaltung gelötet.
			</p>
			<h1>3. Programmierung</h1>
			<p>
Der Programmcode lässt sich in vier größere Sinnabschnitte gliedern:
			</p>
			<ul>
				<li>die Hauptroutine, die das Grundgerüst bildet</li>
				<li>die Navigationsroutine, die GPS-Daten verarbeitet und Routenberechnungen durchführt</li>
				<li>die Hinderniserkennungsroutine, die Gegenständen auf der zu fahrenden Bahn ausweicht</li>
				<li>Hardwarenaher Code, welcher Daten von Sensoren verarbeitet und die Motoren steuert</li>
			</ul>
			<h2>Hauptroutine</h2>
			<p><em>Überblick</em></p><!--TODO-->
			<p>Die main-Funktion bedient sich zweier Hilfsfunktionen:</p>
			<h3>is_at(current, target)</h3>
			<p>
prüft ob sich das Auto bis auf einen Schwellenwert genau am Ziel befindet
			</p>
			<h3>correct_course(direction, angle, radius, speed=SPEED, watcher=None)</h3>
			<p>
korrigiert den Kurs durch befahren einer Kreisbahn in der durch direction vorgegebenen Richtung. Die Länge der Kreisbahn ist durch angle und radius vorgegeben. Die Geschwindigkeit ist variabel, es wird jedoch empfohlen so langsam wie möglich zu fahren. Watcher ist ein Objekt der Klasse Watcher, welche für die Hinderniserkennung zuständig ist. Während der Kurskorrektur wird auf Hindernisse geprüft.
			</p>
			<pre>
if __name__ == '__main__':
	try:
		target = tuple(float(i) for i in sys.argv[1:3])
	except ValueError:
		target = None
	mainRoutine(target)
			</pre>
			<p>und:</p>
			<pre>
def mainRoutine(target):
	if target is None or len(target) != 2:
		print "no reasonable target given"
		return
			</pre>
			<p>
Sind die Eingaben nicht von der Form "Zahl_1 Zahl_2", so beendet das Programm.
Sind die Eingaben richtig, dann werden die nötigen Instanzen unterschiedlicher Klassen erzeugt und initialisiert:
			</p>
			<pre>
	tracker = GPSTracker()
	navigator = Navigator(tracker)
	navigator.setRadius(RADIUS)
	
	watcher = Watcher()
			</pre>
			<p>
Die Klasse GPSTracker ermöglicht die Position des Autos sowie dessen Orientierung anhand der letzten Positionen zu bestimmen.
Die Klasse Navigator berechnet den Kurs, der angesteuert werden muss um das Auto zum Ziel zu führen.
Watcher implementiert die Überwachung der Strecke vor dem Auto sowie den Ausweichalgorithmus für etwaige Hindernisse.
			</p>
			<p>
Als nächstes muss auf ein GPS-Signal gewartet werden. Sobald dieses vorliegt wird in eine Endlosschleife eingetreten und zunächst überprüft, ob das Auto gerade stillsteht. 
Ist dies der Fall, so steht es noch am Anfang seiner Reise. Daher muss zunächst die Orientierung bestimmt werden, damit der Navigator den Kurs berechnen kann. Dazu muss die Liste der letzten Positionen des GPSTrackers gefüllt werden, also fährt das Auto zunächst ca. fünf Meter, füllt dabei über tracker.getPosition() die Liste und hält dann wieder an. Später wurde das GPS-Modul auf einer Stange befestigt, und damit wurde diese Weise der Orientierungsbestimmung überflüssig. In der letzten Version der Software wird die Orientierung über den Kompass abgefragt. 
Fährt das Auto gerade, so wird lediglich die Variable driving auf True gesetzt.
			</p>
			<pre>
	while True:
		if is_at(curPos, tracker.getPosition()):	# car stands still
			print "standing"
			start = time.time()
			print "driving at", speed
			drive(speed)			#drive for 5m
			while (time.time() - start) < 2:	#while driving (ca. 2 s) save 								 positions to tracker
				watcher.obstancle()
				tracker.getPosition()
			stop()
			# renavigate
			line = None
		else:
			driving = True
			</pre>
			<p>
Dann wird überprüft ob das Auto bereits an seinem Ziel angekommen ist. Falls dem so ist, hält es an und das Programm bricht aus der Schleife aus.
Ist es nicht an seinem Ziel, wird überprüft ob sich das Auto auf dem richtigen Kurs befindet und gegebenenfalls auf den korrekten Kurs gebracht.
			</p>
			<p>
Die letzte if-Anweisung prüft, ob das Auto gerade fährt - und wenn dem so ist, speichert es seine Position in die Liste der letzten Positionen des GPSTrackers und prüft auf Hindernisse.
			</p>
			<h2>Navigationsroutine</h2>
			<p>Die Navigationsroutine umschließt drei Dateien:</p>
			<h3>__init__.py</h3>
			<p>
enthält Klassendefinitionen für GPSPoller und GPSTracker, die nötig sind, um das GPS-Modul anzusteuern.
			</p>
			<h3>helpers.py</h3>
			<p>
enthält Hilfsfunktionen für die Berechnungen des Kurses.
			</p>
			<h3>navigate.py</h3>
			<p>
enthält die Klassendefinition für Navigator, welche für die Berechnung des Kurses zuständig ist.
			</p>
			<p>
Die navigate()-Funktion ist das Herzstück der Navigationsroutine.
Nachdem für die aktuelle Position sowie die Zielkoordinate die jeweiligen Längen- und Breitengrade extrahiert wurden, wird die Orientierung des Autos bestimmt.
			</p>
			<!--TODO mehr-->
			<h2>Hinderniserkennungsroutine</h2>
			<p>
Die Hinderniserkennungsroutine wird durch die Klasse Watcher umgesetzt, welche folgenden Funktionen enthält:
			</p>
			<h3>alarm</h3>
			<p>
gibt die zuletzt gemessenen Abstände zu Objekten auf der linken und rechten Seite des Autos zurück.
			</p>
			<h3>watch</h3>
			<p>
fragt die Ultraschallsensoren ab und füllt jeweils eine Liste für jeden Sensor mit Messwerten.
			</p>
			<h3>obstancle</h3>
			<p>
prüft auf Hindernisse im Bereich von 1.5 Metern vor dem Auto und weicht aus, falls ein Hindernis erkannt wird. Wie stark hierbei gelenkt wird, um auszuweichen ist von der Distanz zum Hindernis abhängig. Das Auto weicht in die Richtung aus, in die eine größere Distanz zum Hindernis gemessen wird. Taucht ein Hindernis unerwarteterweise weniger als einen halben Meter vor dem Auto auf, so wird entweder rückwärts nach links (Hindernis auf der linken Seite; effektiv wird rückwärts nach rechts gefahren) oder rechts (Hindernis auf der rechten Seite; effektiv wird rückwärts nach links gefahren) gesteuert um auszuweichen.
			</p>
			<h2>Hardwarenaher Code</h2>
			<p>
Der hardwarenahe Code umfasst zum einen die Dateien controlServos.py und drive.py, welche für die Ansteuerung der Motoren des Autos zuständig sind und die Fahrtfunktionen enthalten und zum anderen die Datei getDistance.py, welche die Ultraschallsensoren abfragt.
			</p>
			<h3>controlServos.py</h3>
			<p>
definiert Variablen für die Länge der zu übermittelnden PWM-Signale für geradeaus lenken/nicht fahren (BASE), rechts lenken (RIGHT), links lenken (LEFT), vorwärts fahren (FORWARD) und rückwärts fahren (BACK). Um Gradierung in Lenkung und Geschwindigkeit zu erlauben, wurden diese Variablen in Abhängigkeit von BASE definiert, sodass man sie mit einem Faktor verwenden kann/muss.<br />
Weiterhin werden die grundlegenden Fahrtfunktionen steerS(deg) und driveS(speed) implementiert, welche jeweils eine Fließkommazahl zwischen -1 (Anschlag rechts bzw. Vollgas rückwärts) und 1 (Anschlag links bzw. Vollgas vorwärts) erwarten.
			</p>
			<h3>drive.py</h3>
			<p>
definiert Fahrfunktionen auf einer höheren Ebene. Anstelle von Gradierungen wird drive(speed) die gewünschte Geschwindigkeit in Metern pro Sekunde, steer_only(radius) der Kurvenradius in Metern und steer_at(speed, radius) beides übergeben. Die stop()-Funktion hält das Auto ohne Input an, während die stunt()-Funktion ein Easter Egg ist, welche einen kleinen Stunt ausführt.
			</p>
			<h3>getDistance.py</h3>
			<p>
setzt benötigte GPIO-Pins des Raspberry Pis so, dass sie für den Input (echo) und Output (trig) für die beiden Ultraschallsensoren verwendet werden können.
Unter Verwendung der Zeit, die die Schallwellen benötigen um nach dem Senden wieder am Sensor anzukommen (timeElapsed) wird die Distanz zum erkannten Objekt in Metern berechnet und zurückgegeben.
			</p>
		</div>
    </body>
</html>
